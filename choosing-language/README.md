# Choosing programming language


_**Task:** Imagine you have to choose a programming language you are going to use for the next 5 years. Which would you consider and why?_

    
_**Task:** What would your manager/boss probably consider when choosing a programming language?_


_**Task:** What would your customer probably say when asked programming language you should use for the project?_


_**Task:** How did you choose the programming language you use most of the time nowadays?_

---

Chances are that you probably picked the language you use now because of very different reasons. The most common answer we get is: **Because we learned it at school.** We do not want to argue about whether schools do pick the right programming languages for you, but at least think about if it meets the criteria you would use today.

**Common developer criteria:**

- Is it suitable for apps that I want to build?
- Is it popular? Trending?
- How about tutorials, documentation and support?
- Are there libraries, frameworks, tools and editors I need in the ecosystem?
- Do I like the syntax?
- How much productivity will I gain?
- Is it universal? Cross-platform?
- How do I deploy apps? Do I need any hosting or licences? How much will it cost?
- How fast is it? Does it compile/run fast?

**Common project manager criteria:**

- How many developers are there using it?
- How expensive are they?
- What are the costs? Licences, software, etc.
- Where are the limits? What can we build with it?
- How much will it save?

**Common customer criteria:**

- Can you deliver faster, cheaper or with higher quality?


Changing programming language is a big step, even if, in the easiest case, you could learn the new syntax in just a few hours. Don't be fooled claims, that you can start to be productive in few weeks or even days. Truly understanding new ecosystem of libraries, frameworks and tooling takes months. If you are jumping into a new programming paradigm than you are used to (e.g. from procedural to object-oriented or functional programming) expect months of full time work to get at least as productive as you are now. Years to master it. Having that said, don't be scared to try out new things, but stay realistic and know the cost. 
 
Watch out for jumping into conclusions when looking at benchmarks, popularity, trends, polls or even job ads. Most of these are skewed, biased or plain wrong. Real world benchmarks are hard to find, micro benchmarks put pressure on things that might not be relevant for you.
 
 ![Computer Language Benchmark Game comparison chart](https://github.com/minio-sk/crafting-web-applications/raw/wip/assets/computer-language-benchmark-game.png)  
 _[Computer Language Benchmark Game](http://benchmarksgame.alioth.debian.org/) compares memory and CPU consumption for various problems in different programming languages. However these problems are very specific and odds are that in your day-to-day work will never write a program even remotely similar to these._
 
 Popularity and trends are very tricky to interpret. 
 
 ![Hacker News Programming language popularity poll](https://github.com/minio-sk/crafting-web-applications/raw/wip/assets/hackernews-poll.png)  
  _[Hacker News](https://news.ycombinator.com/item?id=3746692) programming language popularity poll won by Python, Ruby and Javascript._
  
 ![TIOBE Programming Community Index](https://github.com/minio-sk/crafting-web-applications/raw/wip/assets/tiobe-index.png)  
   _[TIOBE Programming Community Index](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) lead by C, Java and Objective-C._
  
  
 The mostly cited TIOBE index, is nothing more than a number of search results you get for a given programming language. [No, not a joke.](http://www.tiobe.com/index.php/content/paperinfo/tpci/tpci_definition.htm)
 
 Programing productivity comparisons fail short in significance because developer-to-developer performance varies greatly. Talk about apples to oranges. 
 
 Job ads mostly reflect demand for programmers, not language features or quality. Make sure you are not jumping into horror legacy system maintenance jobs (unless you like it or desperately need cash). In short, **triple check you understand the data behind any benchmark or comparison table**. Next years of your life are at stake here. 

